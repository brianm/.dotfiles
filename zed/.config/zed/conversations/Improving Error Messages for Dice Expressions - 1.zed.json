{"id":"55485e38-aaf0-4b72-8f98-5b3fdcbecbc7","zed":"context","version":"0.4.0","text":"\n\n```rs dice/src/main.rs\nuse anyhow::{bail, Result};\nuse clap::{CommandFactory, Parser as ClapParser};\nuse pest;\nuse pest::Parser;\nuse proptest::prelude::*;\nuse rand;\nuse rand::Rng;\nuse rayon::prelude::*;\nuse rustyline::DefaultEditor;\nuse std::fmt;\n\n#[macro_use]\nextern crate pest_derive;\n\nfn main() -> Result<()> {\n    let args = Cli::parse();\n    if args.expression.len() == 0 {\n        // start up the REPL\n        let mut rl = DefaultEditor::new()?;\n        println!(\"dice {0}\", env!(\"CARGO_PKG_VERSION\"));\n        println!(\"enter 'help' for help, 'exit' to exit\");\n        loop {\n            let readline = rl.readline(\">> \");\n            match readline {\n                Ok(line) => {\n                    let line = line.trim();\n                    match line.as_ref() {\n                        \"exit\" => return Ok(()),\n                        \"help\" | \"?\" => {\n                            let mut c = Cli::command();\n                            let h = c.render_long_help();\n                            c.write_long_help(&mut std::io::stdout())?;\n                            println!(\"{}\", h);\n                        }\n                        _ => {\n                            rl.add_history_entry(line)?;\n                            line.split(char::is_whitespace)\n                                .filter_map(|s| parse(s).ok())\n                                .for_each(|r| args.print(&r, &r.roll()));\n                        }\n                    }\n                }\n                Err(rustyline::error::ReadlineError::Eof) => return Ok(()),\n                Err(e) => anyhow::bail!(e),\n            }\n        }\n    } else {\n        for roll in &args.expression {\n            let r = parse(roll)?;\n            args.print(&r, &r.roll());\n        }\n    }\n\n    return Ok(());\n}\n\nfn roll_die(size: u64) -> u64 {\n    return rand::rng().random_range(1..=size);\n}\n\nproptest! {\n    #[test]\n    fn test_roll_sizes(size in 1..10000000) {\n        let rs = roll_die(size as u64);\n        assert!(rs >= 1);\n        assert!(rs <= size as u64);\n    }\n}\n\n/// # Rolls dice using a small expression language:\n///\n/// The simplest expression is just a number, indicating to roll\n/// a die with that many sides, ie: `dice 20` or `dice d20` to roll a 20 sided die.\n///\n/// If you want to roll multiple dice you can specify how many with a prefix,\n/// for example three dice with six sides each would be `3d6`.\n///\n/// Run without any expressions to enter interactive mode.\n///\n/// You can then specify how many dice to keep or drop from the roll. To drop dice\n/// use `d` or `D` to drop low rolls or high rolls respectively. For example,\n/// `4d6d1` says to \"roll four dice with six sides dropping the lowest die\", whereas\n/// `2d20D1` says to \"roll two dice with twenty sides each dropping the higher one\".\n///\n/// The same thing works for keep with `k` and `K`, with `k` meaning to keep higher\n/// rolls and `K` to keep lower rolls. This is different from `d` and `D`. Basically\n/// it defaults (lower case) to the belief you want high rolls, therefore that is\n/// easier to type (no need for the `shift` to get capital) :-) If you find it annoying\n/// to use, let me know and I'll consider changing it in a future version.\n///\n/// Finally, you may add a constant modifier to the roll by appending `+` or `-` and\n/// a value, such as `4d6+1` `3d6-2` or `2d20K1+7`\n///\n/// You can also send multiple expressions:\n///\n/// `dice 4d6d1 4d6d1 4d6d1 4d6d1 4d6d1 4d6d1`\n///\n/// In summary:\n///\n///     3d6      3 x d6\n///\n///     4d6d1    3 x d6 dropping lowest\n///\n///     20+1     1 x d20 and add one to the result\n///\n///     2d8K1-1  2 x d8 keep the lower and subtract 1\n///\n#[derive(ClapParser)]\n#[command(author, version, about)]\n#[command(propagate_version = true)]\nstruct Cli {\n    /// Quiet output (just the result)\n    #[structopt(short, long)]\n    quiet: bool,\n    /// Roll expressions, ie `4d6k3 4d6d1`\n    expression: Vec<String>,\n}\n\nimpl Cli {\n    fn print(&self, spec: &RollSpec, roll: &Roll) {\n        if self.quiet {\n            println!(\"{}\", roll.sum)\n        } else {\n            println!(\"{}\\t{}\", spec, roll)\n        }\n    }\n}\n\n#[derive(Debug)]\nstruct RollSpec {\n    num: usize,\n    size: i64,\n    keep_high: usize,\n    keep_low: usize,\n    drop_low: usize,\n    drop_high: usize,\n    modifier: i64,\n}\n\nimpl fmt::Display for RollSpec {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let mut suffix = String::from(\"\");\n        if self.keep_high > 0 {\n            suffix.push_str(&format!(\" keep highest {}\", self.keep_high));\n        } else if self.drop_low > 0 {\n            suffix.push_str(&format!(\" drop lowest {}\", self.drop_low));\n        } else if self.drop_high > 0 {\n            suffix.push_str(&format!(\" drop highest {}\", self.drop_high));\n        } else if self.keep_low > 0 {\n            suffix.push_str(&format!(\" keep lowest {}\", self.keep_low));\n        }\n\n        let mut modifier = String::from(\"\");\n        if self.modifier > 0 {\n            modifier.push_str(&format!(\" +{}\", self.modifier));\n        } else if self.modifier < 0 {\n            modifier.push_str(&format!(\" {}\", self.modifier));\n        }\n\n        write!(f, \"{}d{}{}{}\", self.num, self.size, suffix, modifier)\n    }\n}\n\nimpl RollSpec {\n    fn roll(&self) -> Roll {\n        let mut rolls: Vec<i64> = (0..self.num)\n            .into_par_iter()\n            .map(|_| roll_die(self.size as u64) as i64)\n            .collect();\n        rolls.par_sort();\n\n        // now that we have the rolls, figure out which to keep\n\n        let range = if self.keep_high != 0 {\n            self.num - self.keep_high..self.num\n        } else if self.drop_low != 0 {\n            self.drop_low..self.num\n        } else if self.drop_high != 0 {\n            0..self.num - self.drop_high\n        } else if self.keep_low != 0 {\n            0..self.keep_low\n        } else {\n            0..self.num\n        };\n\n        let mut sum = rolls[range].par_iter().sum();\n        sum += self.modifier;\n\n        return Roll { rolls, sum };\n    }\n}\n\nstruct Roll {\n    rolls: Vec<i64>,\n    sum: i64,\n}\n\nimpl fmt::Display for Roll {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"{:?}\\t{}\", self.rolls, self.sum)\n    }\n}\n\n#[derive(Parser)]\n#[grammar = \"expr.pest\"]\npub struct ExprParser;\n\nfn parse<S: Into<String>>(it: S) -> Result<RollSpec> {\n    let s: &str = &it.into();\n    let expr = ExprParser::parse(Rule::expression, s)?\n        .next()\n        .expect(\"Unable to read expression\");\n\n    let mut r = RollSpec {\n        num: 1,\n        size: 0,\n        drop_low: 0,\n        drop_high: 0,\n        keep_low: 0,\n        keep_high: 0,\n        modifier: 0,\n    };\n\n    for part in expr.into_inner() {\n        match part.as_rule() {\n            Rule::n_dice => r.num = part.as_str().parse()?,\n            Rule::die_size => r.size = part.as_str().parse()?,\n            Rule::n_low_to_drop => r.drop_low = part.as_str().parse()?,\n            Rule::n_low_to_keep => r.keep_low = part.as_str().parse()?,\n            Rule::n_high_to_keep => r.keep_high = part.as_str().parse()?,\n            Rule::n_high_to_drop => r.drop_high = part.as_str().parse()?,\n            Rule::add_value => r.modifier = part.as_str().parse()?,\n            Rule::subtract_value => r.modifier = -1 * part.as_str().parse::<i64>()?,\n            Rule::junk => bail!(\"Unexpected input in {}: '{}'\", s, part.as_str()),\n            _ => panic!(\"unexpected token! {}\", part),\n        }\n    }\n\n    return Ok(r);\n}\n\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_parse_3d6() {\n        match parse(\"3d6\") {\n            Ok(r) => println!(\"roll: {}\", r),\n            Err(e) => eprintln!(\"NOOOOOO {}\", e),\n        }\n    }\n\n    #[test]\n    fn test_parse_d6() {\n        match parse(\"d6\") {\n            Ok(r) => println!(\"roll: {}\", r),\n            Err(e) => eprintln!(\"NOOOOOO {}\", e),\n        }\n    }\n\n    #[test]\n    fn test_parse_6() {\n        match parse(\"6\") {\n            Ok(r) => println!(\"roll: {}\", r),\n            Err(e) => eprintln!(\"NOOOOOO {}\", e),\n        }\n    }\n\n    #[test]\n    fn test_parse_garbage() {\n        match parse(\"3d8*2\") {\n            Ok(_r) => assert!(1 + 1 == 3),\n            Err(_e) => assert!(1 + 2 == 3),\n        }\n    }\n\n    #[allow(dead_code)] // used in proptest, which fools the linter\n    const EXPR_PATTERN: &str = \"[1-9]?{1}d[1-9]((d[1-9])|(k[1-9]))?(-[1-9])?\";\n    proptest! {\n\n        #[test]\n        fn test_various_parses(expr in EXPR_PATTERN) {\n            match parse(expr) {\n                Ok(_r) => assert!(1+1 == 2),\n                Err(_e) => assert!(1+2 == 2),\n            }\n\n        }\n    }\n}\n```\n\n```pest dice/src/expr.pest\nn_dice   =  { ASCII_DIGIT+ }\nnum_expr = _{ n_dice? ~ \"d\" }\n\ndie_size = { ASCII_DIGIT+ }\n\nn_low_to_drop  = { ASCII_DIGIT+ }\nn_high_to_keep = { ASCII_DIGIT+ }\nn_high_to_drop = { ASCII_DIGIT+ }\nn_low_to_keep  = { ASCII_DIGIT+ }\n\ndrop_keep = _{\n    (\"d\" ~ n_low_to_drop)\n  | (\"D\" ~ n_high_to_drop)\n  | (\"k\" ~ n_high_to_keep)\n  | (\"K\" ~ n_low_to_keep)\n}\n\nadd_value      =  { ASCII_DIGIT+ }\nsubtract_value =  { ASCII_DIGIT+ }\nmodifier       = _{ (\"+\" ~ add_value) | (\"-\" ~ subtract_value) }\njunk           =  { ANY+ }\n\nexpression = { num_expr? ~ die_size ~ drop_keep? ~ modifier? ~ junk? }\n```\n\n\nhow do I improve the error messages when people use bad expressions?\nImproving error messages in your Rust application involves providing more context and clarity about what went wrong and how the user can fix it. Here are some steps you can take to improve the error messages for bad expressions in your dice rolling application:\n\n1. **Enhance the `parse` function to provide more detailed error messages:**\n   - Instead of using `bail!` with a generic message, provide specific messages for different kinds of errors.\n   - Use the `Error` type from `anyhow` to create custom error messages.\n\n2. **Update the `junk` rule in your `expr.pest` file to capture unexpected input more effectively:**\n   - You can use a custom error message for the `junk` rule to indicate what part of the input was unexpected.\n\n3. **Provide examples of valid expressions in the error messages:**\n   - This helps users understand what kind of input is expected.\n\nHere's how you can implement these improvements:\n\n### Update `parse` Function\n\nUpdate the `parse` function to provide more detailed error messages:\n\n```rust\nfn parse<S: Into<String>>(it: S) -> Result<RollSpec> {\n    let s: &str = &it.into();\n    let expr = ExprParser::parse(Rule::expression, s)\n        .map_err(|e| anyhow::anyhow!(\"Failed to parse expression '{}': {}\", s, e))?\n        .next()\n        .expect(\"Unable to read expression\");\n\n    let mut r = RollSpec {\n        num: 1,\n        size: 0,\n        drop_low: 0,\n        drop_high: 0,\n        keep_low: 0,\n        keep_high: 0,\n        modifier: 0,\n    };\n\n    for part in expr.into_inner() {\n        match part.as_rule() {\n            Rule::n_dice => r.num = part.as_str().parse().map_err(|e| anyhow::anyhow!(\"Invalid number of dice '{}': {}\", part.as_str(), e))?,\n            Rule::die_size => r.size = part.as_str().parse().map_err(|e| anyhow::anyhow!(\"Invalid die size '{}': {}\", part.as_str(), e))?,\n            Rule::n_low_to_drop => r.drop_low = part.as_str().parse().map_err(|e| anyhow::anyhow!(\"Invalid number of low dice to drop '{}': {}\", part.as_str(), e))?,\n            Rule::n_low_to_keep => r.keep_low = part.as_str().parse().map_err(|e| anyhow::anyhow!(\"Invalid number of low dice to keep '{}': {}\", part.as_str(), e))?,\n            Rule::n_high_to_keep => r.keep_high = part.as_str().parse().map_err(|e| anyhow::anyhow!(\"Invalid number of high dice to keep '{}': {}\", part.as_str(), e))?,\n            Rule::n_high_to_drop => r.drop_high = part.as_str().parse().map_err(|e| anyhow::anyhow!(\"Invalid number of high dice to drop '{}': {}\", part.as_str(), e))?,\n            Rule::add_value => r.modifier = part.as_str().parse().map_err(|e| anyhow::anyhow!(\"Invalid add value '{}': {}\", part.as_str(), e))?,\n            Rule::subtract_value => r.modifier = -1 * part.as_str().parse::<i64>().map_err(|e| anyhow::anyhow!(\"Invalid subtract value '{}': {}\", part.as_str(), e))?,\n            Rule::junk => bail!(\"Unexpected input in '{}': '{}'\", s, part.as_str()),\n            _ => panic!(\"unexpected token! {}\", part),\n        }\n    }\n\n    Ok(r)\n}\n```\n\n### Update `expr.pest` File\n\nUpdate the `expr.pest` file to capture unexpected input more effectively:\n\n```pest\nn_dice   =  { ASCII_DIGIT+ }\nnum_expr = _{ n_dice? ~ \"d\" }\n\ndie_size = { ASCII_DIGIT+ }\n\nn_low_to_drop  = { ASCII_DIGIT+ }\nn_high_to_keep = { ASCII_DIGIT+ }\nn_high_to_drop = { ASCII_DIGIT+ }\nn_low_to_keep  = { ASCII_DIGIT+ }\n\ndrop_keep = _{\n    (\"d\" ~ n_low_to_drop)\n  | (\"D\" ~ n_high_to_drop)\n  | (\"k\" ~ n_high_to_keep)\n  | (\"K\" ~ n_low_to_keep)\n}\n\nadd_value      =  { ASCII_DIGIT+ }\nsubtract_value =  { ASCII_DIGIT+ }\nmodifier       = _{ (\"+\" ~ add_value) | (\"-\" ~ subtract_value) }\njunk           =  { ANY+ }\n\nexpression = { num_expr? ~ die_size ~ drop_keep? ~ modifier? ~ junk? }\n```\n\n### Provide Examples in Error Messages\n\nYou can provide examples of valid expressions in the error messages to help users understand what kind of input is expected. For example:\n\n```rust\nfn parse<S: Into<String>>(it: S) -> Result<RollSpec> {\n    let s: &str = &it.into();\n    let expr = ExprParser::parse(Rule::expression, s)\n        .map_err(|e| anyhow::anyhow!(\"Failed to parse expression '{}': {}. Examples of valid expressions: '3d6', 'd20', '4d6d1', '2d20K1+7'\", s, e))?\n        .next()\n        .expect(\"Unable to read expression\");\n\n    let mut r = RollSpec {\n        num: 1,\n        size: 0,\n        drop_low: 0,\n        drop_high: 0,\n        keep_low: 0,\n        keep_high: 0,\n        modifier: 0,\n    };\n\n    for part in expr.into_inner() {\n        match part.as_rule() {\n            Rule::n_dice => r.num = part.as_str().parse().map_err(|e| anyhow::anyhow!(\"Invalid number of dice '{}': {}\", part.as_str(), e))?,\n            Rule::die_size => r.size = part.as_str().parse().map_err(|e| anyhow::anyhow!(\"Invalid die size '{}': {}\", part.as_str(), e))?,\n            Rule::n_low_to_drop => r.drop_low = part.as_str().parse().map_err(|e| anyhow::anyhow!(\"Invalid number of low dice to drop '{}': {}\", part.as_str(), e))?,\n            Rule::n_low_to_keep => r.keep_low = part.as_str().parse().map_err(|e| anyhow::anyhow!(\"Invalid number of low dice to keep '{}': {}\", part.as_str(), e))?,\n            Rule::n_high_to_keep => r.keep_high = part.as_str().parse().map_err(|e| anyhow::anyhow!(\"Invalid number of high dice to keep '{}': {}\", part.as_str(), e))?,\n            Rule::n_high_to_drop => r.drop_high = part.as_str().parse().map_err(|e| anyhow::anyhow!(\"Invalid number of high dice to drop '{}': {}\", part.as_str(), e))?,\n            Rule::add_value => r.modifier = part.as_str().parse().map_err(|e| anyhow::anyhow!(\"Invalid add value '{}': {}\", part.as_str(), e))?,\n            Rule::subtract_value => r.modifier = -1 * part.as_str().parse::<i64>().map_err(|e| anyhow::anyhow!(\"Invalid subtract value '{}': {}\", part.as_str(), e))?,\n            Rule::junk => bail!(\"Unexpected input in '{}': '{}'. Examples of valid expressions: '3d6', 'd20', '4d6d1', '2d20K1+7'\", s, part.as_str()),\n            _ => panic!(\"unexpected token! {}\", part),\n        }\n    }\n\n    Ok(r)\n}\n```\n\nBy providing more detailed error messages and examples of valid expressions, you can help users understand what went wrong and how to correct their input.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":590}}},{"id":{"replica_id":0,"value":30},"start":9301,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":591}}},{"id":{"replica_id":0,"value":31},"start":15435,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":592}}}],"summary":"Improving Error Messages for Dice Expressions","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default","metadata":null},{"range":{"start":2,"end":8614},"icon":"File","label":"dice/src/main.rs","metadata":{"path":"dice/src/main.rs"}},{"range":{"start":8615,"end":9230},"icon":"File","label":"dice/src/expr.pest","metadata":{"path":"dice/src/expr.pest"}}]}